;;Need to check special cases inf,zero,NAN
var48 = scrap+4
mulSingle:
;Inputs: HL points to float1, DE points to float2, BC points to where the result is copied
;Outputs: float1*float2 is stored to (BC)
;573+mul24+{0,35}+{0,30}
;min: 1398cc
;max: 2564cc
;avg: 2055.13839751681cc
    push af
    push hl
    push de
    push bc

    call +_   ;CHLB
    ld a,c
    ex de,hl
    pop hl
    push hl
    ld (hl),b \ inc hl
    ld (hl),e \ inc hl
    ld (hl),d \ inc hl
    ld (hl),a
    pop bc
    pop de
    pop hl
    pop af
    ret


_:
;;return float in CHLB
    push de
    ld e,(hl)
    inc hl
    ld d,(hl)
    inc hl
    ld c,(hl)
    inc hl
    ld a,(hl)
    ex de,hl
    ex (sp),hl
    ld e,(hl)
    inc hl
    ld d,(hl)
    inc hl
    ld b,(hl)
    inc hl


    add a,(hl)      ;\
    pop hl          ; |
    rra             ; |Lots of help from Runer112 and
    adc a,a         ; |calc84maniac for optimizing
    jp po,bad       ; |this exponent check.
    xor 80h         ; |
    jr z,underflow  ;/
    push af         ;exponent
    ld a,b
    xor c
    push af         ;sign
    set 7,b
    set 7,c
    call mul24      ;BDE*CHL->HLBCDE, returns sign info
    pop de
    ld a,e
    pop de
    jp m,+_
    rl c
    rl b
    adc hl,hl
    dec d
_:
    inc d
    jr z,overflow
    rl c
    ld c,d
    ld de,0
    push af
    ld a,b
    adc a,e
    ld b,a
    adc hl,de
    jr nc,+_
    inc c \ jr z,overflow
    rr h
    rr l
    rr b
_:
    pop af
    cpl
    and $80
    xor h
    ld h,a
    ret
bad:
    jr c,overflow
underflow:
    ld hl,0
    rl b
    rr h
    ld c,l
    ld b,l
    ret
overflow:
    ld hl,$8000
    jr underflow+3
.echo "mulSingle:",$-mulSingle
mul24:
;;BDE*CHL -> HLBCDE
;;155 bytes
;;402+3*C_Times_BDE
;;fastest:1201cc
;;slowest:1753cc
;;avg    :1464.9033203125cc (1464+925/1024)
;min: 825cc
;max: 1926cc
;avg: 1449.63839751681cc

    push bc
    ld c,l
    push hl
    call C_Times_BDE
    ld (var48),hl
    ld l,a
    ld h,c
    ld (var48+2),hl

    pop hl
    ld c,h
    call C_Times_BDE
    push bc
    ld bc,(var48+1)
    add hl,bc
    ld (var48+1),hl
    pop bc
    ld b,c
    ld c,a
    ld hl,(var48+3)
    ld h,0
    adc hl,bc
    ld (var48+3),hl

    pop bc
    call C_Times_BDE
    ld de,(var48+2)
    add hl,de
    ld (var48+2),hl
    ld d,c
    ld e,a
    ld b,h
    ld c,l
    ld hl,(var48+4)
    ld h,0
    adc hl,de
    ld de,(var48)
    ret
.echo "mul24:",$-mul24


C_times_BDE:
;;C*BDE => CAHL
;C = 0     157
;C = 1     141
;141+
;C>=128    135+6{0,33+{0,1}}+{0,20+{0,8}}
;C>=64     115+5{0,33+{0,1}}+{0,20+{0,8}}
;C>=32     95+4{0,33+{0,1}}+{0,20+{0,8}}
;C>=16     75+3{0,33+{0,1}}+{0,20+{0,8}}
;C>=8      55+2{0,33+{0,1}}+{0,20+{0,8}}
;C>=4      35+{0,33+{0,1}}+{0,20+{0,8}}
;C>=2      15+{0,20+{0,8}}
;min: 141cc
;max: 508cc
;avg: 349.21279907227cc

  ld a,b
  ld h,d
  ld l,e
  sla c \ jr c,mul8_24_1
  sla c \ jr c,mul8_24_2
  sla c \ jr c,mul8_24_3
  sla c \ jr c,mul8_24_4
  sla c \ jr c,mul8_24_5
  sla c \ jr c,mul8_24_6
  sla c \ jr c,mul8_24_7
  sla c \ ret c
  ld a,c
  ld h,c
  ld l,c
  ret
mul8_24_1:
    add hl,hl \ rla \ rl c \ jr nc,$+7 \ add hl,de \ adc a,b \ jr nc,$+3 \ inc c
mul8_24_2:
    add hl,hl \ rla \ rl c \ jr nc,$+7 \ add hl,de \ adc a,b \ jr nc,$+3 \ inc c
mul8_24_3:
    add hl,hl \ rla \ rl c \ jr nc,$+7 \ add hl,de \ adc a,b \ jr nc,$+3 \ inc c
mul8_24_4:
    add hl,hl \ rla \ rl c \ jr nc,$+7 \ add hl,de \ adc a,b \ jr nc,$+3 \ inc c
mul8_24_5:
    add hl,hl \ rla \ rl c \ jr nc,$+7 \ add hl,de \ adc a,b \ jr nc,$+3 \ inc c
mul8_24_6:
    add hl,hl \ rla \ rl c \ jr nc,$+7 \ add hl,de \ adc a,b \ jr nc,$+3 \ inc c
mul8_24_7:
    add hl,hl \ rla \ rl c \ ret nc \ add hl,de \ adc a,b \ ret nc \ inc c \ ret
