#ifndef inc_pushpop
#include "pushpop.z80"
#endif
#define fpOP1 scrap+9
#define fpOP2 scrap+13
#define exp   scrap+17
single2str:
ftos:
;Uses 20 bytes at scrap
  call pushpop
  push bc
  call +_
  pop de
  ld a,e
  ld hl,scrap+4
  cp l
  jr nz,$+5
  ld a,d
  cp h
  ret z
  ld hl,scrap+4
  ld a,(hl)
  or a
  ldi
  jr nz,$-4
  ret
_:
  call tofpOP2
  dec de
  ld a,(de)
  sub 128
  push af   ;carry means we need to multiply by 10^x, nc means divide
  jr nc,$+4
  neg       ;CPL would cause possible values smaller than .1, requiring an additional check.
  ld l,a
  ld h,0
  ld c,l
  ld b,h
  add hl,hl
  add hl,hl
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,bc
  add hl,hl
  add hl,hl
  add hl,bc
  ld a,h
  ld (exp),a ;this is the exponent
#ifdef fast
;10 bytes, 47cc
  ld h,b
  ld l,b
  ld (fpOP1),hl
  ld h,80h
  ld (fpOP1+2),hl
#else
;6 bytes, 111cc
  ld hl,const_1
  call tofpOP1
#endif
  ld de,fpOP1
  ld b,d
  ld c,e
  rra \ ld hl,pow10LUT \ call c,mulSingle
  rra \ ld hl,pow10LUT+4 \ call c,mulSingle
  rra \ ld hl,pow10LUT+8 \ call c,mulSingle
  rra \ ld hl,pow10LUT+12 \ call c,mulSingle
  rra \ ld hl,pow10LUT+16 \ call c,mulSingle
  rra \ ld hl,pow10LUT+20 \ call c,mulSingle
  pop af
  ld hl,fpOP2
  ld b,h
  ld c,l
  call nc,divSingle
  jr nc,+_
  call mulSingle
  ld a,(exp)
  neg
  ld (exp),a
_:
  ld a,(fpOP2+2)
  sub 80h
  ld bc,scrap+4
  jr c,+_
  ld (fpOP2+2),a
  ld a,$1A   ;negative sign
  ld (bc),a
  inc bc
_:
  xor a
  ld (bc),a
  inc bc
  xor a
  ld (bc),a
  inc bc
  xor a
  ld (bc),a
  inc bc
  call fpfix8_24
  ld hl,exp
  ld a,(scrap+3)
  or a
  jr nz,$+5
  dec (hl)
  jr +_
  cp 10
  jr c,+_
  ld de,$0AFF   ;could do 0A2F, but need to add 30h anyways for other routine that is piggybacking
  inc (hl)
  inc e \ sub d \ jr nc,$-2
  add a,30h
  ld (bc),a
  inc bc
  ld a,e
_:
  add a,30h
  ld (bc),a
  inc bc
  ld a,'.'
  ld (bc),a
  inc bc
_:
  call mul10_sub_
  add a,30h
  ld (bc),a
  inc bc
  ld hl,-scrap-17
  add hl,bc
  jr nc,-_
  ld h,b
  ld l,c
_:
;We want to make sure our string has at most 8 digits before rounding. The negative sign will get in the way.
;We want to round the string, returning at most 7 digits
  ld a,(scrap+4)
  cp $1A  ;check if it is a negative.
  jr z,$+3
  dec hl
  dec hl
  ld a,(hl) \ cp 35h
  push hl
  dec hl
  jr c,noroundstr
  ld a,(hl)
_:
  inc a
  ld (hl),a
  cp '9'+1
  jr nz,+_+2
  ld (hl),'0'
  dec hl
  ld a,(hl)
  or a
  jr z,+_
  cp '.'
  jr nz,-_
  dec hl
  ld a,(hl)
  or a
  jr nz,-_
_:
  ld (hl),'1'
noroundstr:
;clean up the leading zeros
  ld hl,scrap+4
  ld a,(hl)
  or a
  ld c,30h
  jr z,$+7
  inc hl
_:
  ld a,(hl) \ or a \ jr nz,$+5 \ ld (hl),c \ jr -_-1
  pop hl
;now we need to move the decimal around
;if exponent<-3, then usee exponential notation
;if 0>exponent>=-3, then move the decimal left.
;if 0=exponent, then no need to move the decimal
;if 0<exponent<7, then move the decimal right
;if exponent>=7, then use exponential notation
  ld a,(exp)
  cp $FD
  jr nc,decimal_stay
  cp 7
  jr c,decimal_stay
;so here we need to clean up 
  or a
  ld (hl),'e'
  inc hl
  jp p,+_
  neg
  ld (hl),$1A   ;negative sign
  inc hl
_:
  
  ld de,$FE0A
  inc d \ sub e \ jr nc,$-2
  add a,e
  add a,30h
  ld e,a
  ld a,d
  add a,31h
  jr c,$+4
  ld (hl),a
  inc hl
  ld (hl),e
  inc hl
removezeroes:
  ld a,l
  sub (scrap+4)&255
  ld c,a
  ld b,0
  ld hl,scrap+4
  ld d,h
  ld e,l
  ld a,(hl)
  cp $1A
  jr nz,+_+1
  inc de
  dec c
  inc hl
_:
  ld a,(hl) \ cp 30h \ jr z,$-5 ;loops back a little before _:
  ldir
  ex de,hl
_:
  dec hl
  ld a,(hl)
  cp 30h
  jr z,-_
  cp '.'
  jr z,$+3
  inc hl
  ld (hl),0
  ret
decimal_stay:
  ld (hl),0
  ld hl,scrap+4
  ld a,'.'
  cpir
  dec hl
  ld d,h
  ld e,l
  ld a,(exp)
  ld b,0
  jr nc,decimalmovleft
  ld c,a
  inc hl
  or a
  jr z,enddecimalmov
  ldir
  jr enddecimalmov
decimalmovleft:
  dec hl
  neg
  ld c,a
  lddr
enddecimalmov:
  ld a,'.'
  ld (de),a
  xor a
  cpir
  dec hl
  jr removezeroes
mul10_sub_:
;(scrap) is treated as an 8.24 fixed-point number
;This multiplies the fractional part by 10.0, storing the result back in (scrap)
;Returns a copy of the integer part in A
  push bc
  ld hl,(scrap)
  ld b,h
  ld c,l
  ld de,(scrap+2)
  xor a
  add hl,hl
  rl e
  rla
  add hl,hl
  rl e
  rla
  ld d,a
  add hl,bc
  ld bc,(scrap+2)
  ld b,0
  ex de,hl
  adc hl,bc
  ex de,hl
  add hl,hl
  ld (scrap),hl
  ex de,hl
  adc hl,hl
  ld (scrap+2),hl
  ld a,h
  pop bc
  ret
fpfix8_24:
;convert the absolute value of the number at HL to 8.24 fixed point at scrap
  ld e,(hl)
  inc hl
  ld d,(hl)
  inc hl
  ld a,(hl)
  or 80h
  inc hl
  ld h,(hl)
  ld l,a
  ld a,h
  sub 80h
  ld h,a
  jr c,+_
_:
;if we get here, it means we need to shift left a times
  ex de,hl
  inc d
  xor a
  add hl,hl \ rl e \ rla \ dec d \ jr nz,$-5
  ld d,a
  ld (scrap),hl \ ld (scrap+2),de
  ret
_:
  inc h
  jr z,+_
  ld a,e
  ld e,h
  srl h \ rr l \ rr d \ rra \ inc e \ jr nz,$-8
  ld e,a
  jr nc,+_
  inc e \ jr nz,+_
  inc d \ jr nz,+_ \ inc hl
_:
  ld (scrap),de \ ld (scrap+2),hl
  ret
tofpOP1:
  ld de,fpOP1
  ldi
  ldi
  ldi
  ldi
  ret
tofpOP2:
  ld de,fpOP2
  ldi
  ldi
  ldi
  ldi
  ret
#undefine exp
#undefine fpOP1
#undefine fpOP2
pow10LUT:
.db $00,$00,$20,$83 ;10
.db $00,$00,$48,$86 ;100
.db $00,$40,$1c,$8d ;10000
.db $20,$bc,$3e,$9a ;10^8
.db $ca,$1b,$0e,$b5 ;10^16
.db $ae,$c5,$1d,$ea ;10^32
