#define pow10exp  fpOP3+32
#define strout fpOP3+34
xtostr:
  push hl
  push de
  push bc
  push af
  push bc
  call +_
  pop de
  ld hl,fpOP2
  ld a,(hl)
  ldi
  or a
  jr nz,$-4
  pop af
  pop bc
  pop de
  pop hl
  ret
_:
  ld de,fpOP1
  call mov10
  ld de,(fpOP1+8)   ;this is the exponent and sign
  ld hl,strout
  bit 7,d
  jr z,+_
  res 7,d
  ld (hl),'-'
  inc hl
_:
  ld a,d
  or e
  jp z,strcase
  ld (fpOP1+8),de   ;just making it positive
  ;Now we need to perform (DE-0x4000)*19728 (approximation of exponent*log10(2))
  ld bc,19728
  push hl       ;points to where the string is being written
  call mul16    ;when analyzing timing, note that the first iteration is guaranteed to skip
  ld hl,-4932
  add hl,de
  ld (pow10exp),hl
  ld de,pow10table
  jr c,+_
;the exponent is negative, need to be multiplying by 10^-exponent
  xor a
  sub l
  ld l,a
  sbc a,a
  sub h
  ld h,a
  ld de,pown10table   ;get the table of 10^-(2^k)
_:
  ld bc,fpOP1
  add hl,hl
  add hl,hl
  add hl,hl
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
  call xtostr_mul
;now the number is pretty close to a nice value
_:
  ld a,(fpOP1+8)
  add a,a
  jr nc,+_
  call fpOP1mul10
  ld hl,(pow10exp)
  dec hl
  ld (pow10exp),hl
  jr -_     ;For speed, could perform test here instead.
_:
;quick, convert to a fixed-point number !
  rra
  inc a
  ;number of bits to shift
  ld b,a
  xor a
  ld (fpOP1+8),a
_:
  ld hl,fpOP1
  sla (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl) \ inc hl
  rl (hl)
  djnz -_
  ld a,(hl) ;the first digit, might be as large as twenty
  pop hl
  cp 10
  jr z,+_
  ld de,(pow10exp)
  dec de
  ld (hl),30h
  inc de \ inc (hl) \ sub 10 \ jr nc,$-4
  ld (pow10exp),de
  add a,10
  inc hl
_:
  add a,'0'
  ld (hl),a
  inc hl
  ld a,l
  cp (strout+20)&255
  jr z,+_
  push hl
  call xtostrmul10
  pop hl
  jr -_
_:
;now I need to format the string data


  ret
strcase:
  ld de,str_Zero
  ld a,(fpOP1+7)
  and $C0
  jr z,+_
  ld de,str_Inf
  jp pe,+_
  ld de,str_NaN
_:
  jp mov4
xtostr_mul:
  add hl,hl
  push hl
  call c,+_
  ld hl,10
  add hl,de
  ex de,hl
  pop hl
  ret
_:
  ld h,b
  ld l,c
  jp xmul
xtostrmul10:
;multiply the 0.64 fixed point number at fpOP1 by 10
;overflow in A register
  ld hl,fpOP1
  ld de,fpOP2
  call mov9
  xor
  inc hl \ sla (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  rla
  ld hl,fpOP2
  sla (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  rla
  inc hl
  ld (hl),a
  ld de,fpOP1
  ld hl,fpOP2
  call add64
  inc hl \ inc de \ ld a,(de) \ adc a,(hl)
  ld hl,fpOP2
  sla (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  inc hl \ rl (hl)
  rla
  ret
#include "../extended/mul/fpOP1mul10.z80"
